# 🧼 Clean Code

> [토스ㅣSLASH 21 - 실무에서 바로 쓰는 Frontend Clean Code](https://www.youtube.com/watch?v=edWbHp_k_9Y&list=PL1DJtS1Hv1PiGXmgruP1_gM2TSvQiOsFL&index=55&t=690s)

<br/>

## 0. 목차

<!-- no toc -->
1. [실무에서의 클린코드의 의의](#1-실무에서의-클린코드의-의의)
2. [안일한 코드 추가의 함정](#2-안일한-코드-추가의-함정)
3. [클린코드는 짧은 코드가 아니라, 원하는 로직을 빠르게 찾을 수 있는 코드다](#3-클린코드는-짧은-코드가-아니라-원하는-로직을-빠르게-찾을-수-있는-코드다)
4. [액션 아이템](#4-액션-아이템)

<br/>

## 1. 실무에서의 클린코드의 의의

- 클린 코드라 하면 '명확한 이름', '중복 줄이기'를 먼저 말하곤 하지만, 실무에서는 이 외에도 조금 더 섬세하게 코드를 정리하는 스킬이 필요하다.
- 클린하지 않은 코드는 흐름 파악이 어렵고, 도메인 맥락 표현이 안 되어, 동료에게 물어봐야 알 수 있는 코드다.
- 이는 개발 시 병목이 되어 기능 추가도 어렵고, 성능도 좋지 못해 유저 입장에서도 쾌적하지 못하다.
- 따라서 실무에서의 클린코드는 '유지보수 시간의 단축'을 말한다고 볼 수 있다.

<br/>

## 2. 안일한 코드 추가의 함정

- 회사에서 우리 일의 90%는 기존 코드에 기능을 추가하는 일이기에, 코드를 안일하게 추가하는 것을 지양해야겠다.
- 예를 들어, 하나의 목적인 코드가 흩뿌려져 있으면 추후 기능 추가 시 스크롤을 위아래로 이동해야 하는 번거로움이 있다.
- 또는 하나의 함수가 여러가지 일을 한다면, 세부 구현을 모두 읽어야 그제서야 함수의 역할을 알 수 있게 된다.
- 함수의 세부 구현 단계가 제각각이라면, 읽을 때 어지럽고 코드를 이상하게 지레짐작하게 될 수 있다.
- 따라서 이때는 큰 그림을 보며 함수의 세부 구현 단계를 통일한다. 한 함수에는 하나의 로직만 담기게끔 위계를 맞춘다.
- 그리고 하나의 목적인 코드는 뭉쳐둔다. 예를 들어, 팝업 관련 코드는 뭉쳐두어 별도의 컴포넌트로 만들고, 띄워줄 팝업은 props로 내려보낸다.
- 마지막으로, 함수가 한 가지 일만 하도록 쪼갠다. 예를 들어, 약관 동의 함수를 별도로 쪼개서 필요한 시점에 부르도록 한다.

<br/>

## 3. 클린코드는 짧은 코드가 아니라, 원하는 로직을 빠르게 찾을 수 있는 코드다

### (1) 하나의 목적을 가진 코드가 흩뿌려져 있다 → 응집도를 높여 뭉쳐둔다

- 만약 한 군데로 뭉쳤다고 해도, 각 함수가 어떤 역할이나 액션을 하는지 훅 속에 가려져 알 수 없게 된다 (커스텀 훅의 대표적인 안티패턴)
- 뭉치면 쾌적: 당장 몰라도 되는 디테일 → 짧은 코드만 보고도 빠르게 코드의 목적을 파악할 수 있다.
- 뭉치면 답답: 코드 파악에 필수적인 핵심 정보 → 분리하면 여러 모듈을 넘나들며 흐름을 따라가야 하는 참사가 발생할 수 있다.
- 따라서, 남겨야 할 핵심 데이터와 숨겨도 될 세부 구현을 나눈다.
- 이러한 개발 스타일을 '선언적 프로그래밍' 이라고 한다. 즉, 핵심 데이터만 전달받고 세부 구현은 뭉쳐 숨겨두는 개발 스타일이다.
- 특징으로는 '무엇'을 하는 함수인지 빠르게 이해가 가능하다는 것, 세부 구현은 안쪽에 뭉쳐두어 신경 쓸 필요가 없다는 것, 그리고 '무엇'만 바꿔서 쉽게 재사용이 가능하다는 점이 있다. (하지만, 선언적 코드가 무조건 좋다는 것은 아니다)

### (2) 함수가 여러가지 일을 하고 있다 → 단일책임 원칙에 의거하여 하나의 일을 하는 뚜렷한 이름의 함수를 만들자

- 중요 포인트가 모두 담겨있지 않은 함수명은 읽는 이가 예상한 대로 코드가 동작하지 않으며, 이는 코드에 대한 신뢰 하락으로 이어진다. 게다가 이미 있는 함수에 기능을 추가만 한다면 더욱 잡탕이 된다.
- 이때 한 가지 일만 하는, 명확한 이름의 함수들을 만들어 두면 필요한 상황에서 따로따로 부르면 된다. 혹은 리액트 컴포넌트로 기능을 분리할 수도 있다.
- 마지막으로, 조건이 많아지면 한글 이름도 유용하다.

### (3) 함수의 세부구현 단계가 제각각이다 → 추상화 단계를 조정해 핵심 개념을 필요한 만큼만 노출한다

- 예를 들어 피카소의 소, 지하철 노선도 추상화 라는 예시를 떠올려보자.
- 코드에 적용한다면, 팝업 코드를 제출 액션과 성공 액션 두 가지 중요한 개념만 남겨 나머지를 추상화할 수 있다.
- 정답은 없다. 상황에 따라 필요한 만큼만 추상화하면 된다.
- 다만, 추상화 수준이 섞여 있으면 코드 파악이 어렵다는 점을 유념하자. 작은 코드라고 생각했는데 복잡한 코드가 나올 수 있다. 이렇게 되면 코드를 읽는데에 사고가 널뛰게 되어 전체적인 코드가 어느 수준으로 구체적으로 기술된지 파악할 수 없다.

<br/>

## 4. 액션 아이템

### (1) 담대하게 기존 코드를 수정한다

- 구조 뜯기를 두려워하면, 클린한 실무 코드를 유지할 수 없다.

### (2) 큰 그림을 보는 연습을 한다

- 그 때는 맞고, 지금은 틀릴 수 있다.
- 기능 추가 자체는 클린하더라도 전체적으로는 어지러울 수 있다.

### (3) 팀과 함께 공감대를 형성한다

- 사소한 것이라도 명시적으로 이야기하는 시간이 필요하다.

### (4) 문서로 적어본다

- 해당 코드가 향후 어떤 점에서 위험할 수 있는지, 어떻게 개선할 수 있는지 등등 나만의 원칙을 정해본다.
- 클린코드란 모호한 개념이기에 글로 적어야 명확해진다.
